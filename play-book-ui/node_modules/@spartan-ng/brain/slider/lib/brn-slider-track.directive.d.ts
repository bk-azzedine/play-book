import type { Direction } from '@angular/cdk/bidi';
import { type AfterViewInit, InjectionToken, type OnDestroy, type Signal, type WritableSignal } from '@angular/core';
import { type ControlValueAccessor } from '@angular/forms';
import type { BrnLabelDirective } from '@spartan-ng/brain/label';
import * as i0 from "@angular/core";
export declare const BRN_SLIDER_INPUT: InjectionToken<BrnSliderInput>;
export interface BrnSliderInput {
    /** The slider's native input element wrapper value. */
    value: Signal<number>;
    /** Flag indicating if native input element is currently focused. */
    isFocused: Signal<boolean>;
}
export declare const BRN_SLIDER_TRACK: InjectionToken<BrnSliderTrack>;
export declare const BRN_SLIDER: InjectionToken<BrnSlider>;
export interface BrnSlider {
    /** The minimun value of the slider. */
    min: WritableSignal<number>;
    /** The maximun value of the slider. */
    max: WritableSignal<number>;
    /** The amount that slider values can increment or decrement by. */
    step: Signal<number>;
    /** Whether the slider is disabled. */
    disabled: WritableSignal<boolean>;
    /** Whether the slider displays tick marks along the slider track. */
    showTickMarks: Signal<boolean>;
    /** Whether the slider is ltr or rtl.
     * Any consumer of slider interested in getting the current
     * direction state, will consume this signal.
     */
    direction: Signal<Direction>;
    /** The underlying slider's track element */
    brnSliderTrack: Signal<BrnSliderTrack | undefined>;
    /** The aria-labelledby element */
    label: Signal<BrnLabelDirective | null>;
    /** The optional aria-label fallback value.
     * If no label is provided, this input must be provided by the user,
     * otherwise an error will be displayed prompting the user to either
     * provide a spartan-ui label or a fallback aria label text.
     */
    ariaLabel: Signal<string | null>;
}
/**
 * Directive that adds slider-specific behaviors to an input element inside `<brn-slider>`.
 */
export declare class BrnSliderInputDirective implements ControlValueAccessor, BrnSliderInput {
    private _onChangeFn;
    private _onTouchedFn;
    protected isDisabled: Signal<true | undefined>;
    protected valueNow: Signal<number>;
    protected valueMin: Signal<number>;
    protected valueMax: Signal<number>;
    protected ariaLabelledby: Signal<import("@angular/core").InputSignal<string> | undefined>;
    protected ariaLabel: Signal<string | null>;
    readonly value: WritableSignal<number>;
    readonly isFocused: WritableSignal<boolean>;
    private readonly _platformId;
    private readonly _elementRef;
    private readonly _slider;
    private readonly _renderer2;
    private readonly _changeDetector;
    constructor();
    onFocus(): void;
    onBlur(): void;
    onInput(): void;
    onChange(): void;
    writeValue(obj: number): void;
    registerOnChange(fn: (value: string | number) => void): void;
    registerOnTouched(fn: () => void): void;
    /**
     * Sets the disabled state of the slider.
     * @param isDisabled The new disabled state
     */
    setDisabledState(isDisabled: boolean): void;
    private _updateHostElementValue;
    private _updateValue;
    private _updateHostElementStep;
    private _updateMinValue;
    private _updateMaxValue;
    private _updateDirection;
    static ɵfac: i0.ɵɵFactoryDeclaration<BrnSliderInputDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<BrnSliderInputDirective, "input[brnSliderInput]", never, {}, {}, never, never, true, never>;
}
export declare class BrnSliderDirective implements BrnSlider, AfterViewInit, OnDestroy {
    readonly label: import("@angular/core").InputSignal<BrnLabelDirective | null>;
    readonly ariaLabel: import("@angular/core").InputSignal<string | null>;
    /** Used only as an input. */
    readonly dir: import("@angular/core").InputSignal<Direction>;
    readonly disabled: import("@angular/core").ModelSignal<boolean>;
    readonly min: import("@angular/core").ModelSignal<number>;
    readonly max: import("@angular/core").ModelSignal<number>;
    readonly step: import("@angular/core").InputSignal<number>;
    readonly showTickMarks: import("@angular/core").InputSignal<boolean>;
    readonly direction: WritableSignal<Direction>;
    private readonly _destroyed;
    private readonly _injector;
    private readonly _dir;
    private readonly _platformId;
    readonly brnSliderTrack: Signal<BrnSliderTrack | undefined>;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     * The method is responsible of setting the current direction state
     * based on the latest 'dir' input or bidi state change. The only
     * source of truth for slider direction state is the 'direction' signal
     * and all interested consumers of it, will consume this interface exposed signal.
     */
    private _updateDirectionality;
    static ɵfac: i0.ɵɵFactoryDeclaration<BrnSliderDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<BrnSliderDirective, "[brnSlider]", ["brnSlider"], { "label": { "alias": "label"; "required": false; "isSignal": true; }; "ariaLabel": { "alias": "ariaLabel"; "required": false; "isSignal": true; }; "dir": { "alias": "dir"; "required": false; "isSignal": true; }; "disabled": { "alias": "brnSliderDisabled"; "required": false; "isSignal": true; }; "min": { "alias": "min"; "required": false; "isSignal": true; }; "max": { "alias": "max"; "required": false; "isSignal": true; }; "step": { "alias": "step"; "required": false; "isSignal": true; }; "showTickMarks": { "alias": "showTickMarks"; "required": false; "isSignal": true; }; }, { "disabled": "brnSliderDisabledChange"; "min": "minChange"; "max": "maxChange"; }, ["brnSliderTrack"], never, true, never>;
}
export interface BrnSliderTrack {
    /** The track's active portion. */
    activeTrackPercentage: Signal<number>;
    /** The host element's bounding client rect width without padding left and right. */
    hostElementWidth: Signal<number>;
    /** The available tick mark track width based on slider's step min and max values. */
    tickMarkTrackWidth: Signal<number>;
    /** The tick marks array indicating if a mark is currently active or inactive. */
    tickMarks: Signal<Array<boolean>>;
    /** The underlying slider's track input element */
    brnSliderInput: Signal<BrnSliderInput | undefined>;
}
export declare class BrnSliderTrackDirective implements BrnSliderTrack, AfterViewInit, OnDestroy {
    readonly hostElementWidth: WritableSignal<number>;
    private readonly _destroyed;
    private readonly _slider;
    private readonly _platformId;
    private readonly _elementRef;
    private readonly _sharedResizeObserver;
    readonly brnSliderInput: Signal<BrnSliderInput | undefined>;
    activeTrackPercentage: Signal<number>;
    tickMarkTrackWidth: Signal<number>;
    tickMarks: Signal<any[]>;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    private _onResize;
    private _storeDimensions;
    static ɵfac: i0.ɵɵFactoryDeclaration<BrnSliderTrackDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<BrnSliderTrackDirective, "[brnSliderTrack]", never, {}, {}, ["brnSliderInput"], never, true, never>;
}
