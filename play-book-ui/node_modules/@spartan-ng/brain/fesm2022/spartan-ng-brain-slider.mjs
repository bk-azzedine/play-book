import { isPlatformBrowser } from '@angular/common';
import * as i0 from '@angular/core';
import { InjectionToken, computed, signal, inject, PLATFORM_ID, ElementRef, Renderer2, ChangeDetectorRef, effect, untracked, Directive, input, model, Injector, contentChild, forwardRef } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { SharedResizeObserver } from '@angular/cdk/observers/private';
import { toObservable } from '@angular/core/rxjs-interop';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subject, merge } from 'rxjs';
import { takeUntil, tap, debounceTime } from 'rxjs/operators';

const BRN_SLIDER_INPUT = new InjectionToken('BrnSliderInput');
const BRN_SLIDER_TRACK = new InjectionToken('BrnSliderTrack');
const BRN_SLIDER = new InjectionToken('BrnSlider');
/**
 * Directive that adds slider-specific behaviors to an input element inside `<brn-slider>`.
 */
class BrnSliderInputDirective {
    _onChangeFn;
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    _onTouchedFn = () => { };
    isDisabled = computed(() => (this._slider.disabled() === true ? true : undefined));
    valueNow = computed(() => this.value() ?? 0);
    valueMin = computed(() => this._slider.min());
    valueMax = computed(() => this._slider.max());
    ariaLabelledby = computed(() => this._slider.label()?.id);
    ariaLabel = computed(() => {
        if (!this._slider.ariaLabel() && !this.ariaLabelledby()) {
            throw new Error("'ariaLabel' input must be provided as fallback accessibility aria label when no aria-labelledby element is provided.");
        }
        return this._slider.ariaLabel();
    });
    value = signal(0);
    isFocused = signal(false);
    _platformId = inject(PLATFORM_ID);
    _elementRef = inject((ElementRef));
    _slider = inject(BRN_SLIDER);
    _renderer2 = inject(Renderer2);
    _changeDetector = inject(ChangeDetectorRef);
    constructor() {
        effect(() => {
            if (isPlatformBrowser(this._platformId)) {
                const step = this._slider.step();
                const min = this._slider.min();
                const max = this._slider.max();
                const direction = this._slider.direction();
                untracked(() => {
                    this._updateHostElementStep(step);
                    this._updateMinValue(min);
                    this._updateMaxValue(max);
                    this._updateDirection(direction);
                });
            }
        });
    }
    onFocus() {
        this.isFocused.set(true);
    }
    onBlur() {
        this.isFocused.set(false);
        this._onTouchedFn();
    }
    onInput() {
        this._updateValue();
    }
    onChange() {
        this._updateValue();
    }
    writeValue(obj) {
        this.value.set(obj);
        this._updateHostElementValue(obj);
    }
    registerOnChange(fn) {
        this._onChangeFn = fn;
    }
    registerOnTouched(fn) {
        this._onTouchedFn = fn;
    }
    /**
     * Sets the disabled state of the slider.
     * @param isDisabled The new disabled state
     */
    setDisabledState(isDisabled) {
        /** Disable slider only when slider component
         * is not disabled and isDisabled param is explicitly set to true
         */
        if (isDisabled && !this._slider.disabled()) {
            this._slider.disabled.set(isDisabled);
        }
    }
    _updateHostElementValue(value) {
        this._elementRef.nativeElement.value = value?.toString() ?? '0';
        this._changeDetector.detectChanges();
    }
    _updateValue() {
        this.value.set(this._elementRef.nativeElement.valueAsNumber);
        this._onChangeFn?.(this.value());
    }
    _updateHostElementStep(step) {
        this._elementRef.nativeElement.step = step.toString();
        this._updateValue();
    }
    _updateMinValue(value) {
        this._elementRef.nativeElement.min = value.toString();
        this._updateValue();
    }
    _updateMaxValue(value) {
        this._elementRef.nativeElement.max = value.toString();
        this._updateValue();
    }
    _updateDirection(direction) {
        this._renderer2.setStyle(this._elementRef.nativeElement, 'direction', direction);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderInputDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.1", type: BrnSliderInputDirective, isStandalone: true, selector: "input[brnSliderInput]", host: { attributes: { "type": "range", "role": "slider", "aria-orientation": "horizontal" }, listeners: { "change": "onChange()", "input": "onInput()", "focus": "onFocus()", "blur": "onBlur()" }, properties: { "attr.disabled": "isDisabled()", "attr.aria-valuenow": "valueNow()", "attr.aria-valuemin": "valueMin()", "attr.aria-valuemax": "valueMax()", "attr.aria-labelledby": "ariaLabelledby()", "attr.aria-label": "ariaLabel()" } }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: BrnSliderInputDirective,
                multi: true,
            },
            {
                provide: BRN_SLIDER_INPUT,
                useExisting: BrnSliderInputDirective,
            },
        ], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderInputDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[brnSliderInput]',
                    host: {
                        type: 'range',
                        role: 'slider',
                        '(change)': 'onChange()',
                        '(input)': 'onInput()',
                        '(focus)': 'onFocus()',
                        '(blur)': 'onBlur()',
                        '[attr.disabled]': 'isDisabled()',
                        '[attr.aria-valuenow]': 'valueNow()',
                        '[attr.aria-valuemin]': 'valueMin()',
                        '[attr.aria-valuemax]': 'valueMax()',
                        '[attr.aria-labelledby]': 'ariaLabelledby()',
                        '[attr.aria-label]': 'ariaLabel()',
                        'aria-orientation': 'horizontal',
                    },
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: BrnSliderInputDirective,
                            multi: true,
                        },
                        {
                            provide: BRN_SLIDER_INPUT,
                            useExisting: BrnSliderInputDirective,
                        },
                    ],
                    standalone: true,
                }]
        }], ctorParameters: () => [] });
class BrnSliderDirective {
    label = input(null);
    ariaLabel = input(null);
    /** Used only as an input. */
    dir = input('ltr');
    disabled = model(false, { alias: 'brnSliderDisabled' });
    min = model(0);
    max = model(100);
    step = input(1);
    showTickMarks = input(false);
    direction = signal('ltr');
    _destroyed = new Subject();
    _injector = inject(Injector);
    _dir = inject(Directionality);
    _platformId = inject(PLATFORM_ID);
    brnSliderTrack = contentChild(BRN_SLIDER_TRACK);
    ngAfterViewInit() {
        if (isPlatformBrowser(this._platformId)) {
            this._updateDirectionality();
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * The method is responsible of setting the current direction state
     * based on the latest 'dir' input or bidi state change. The only
     * source of truth for slider direction state is the 'direction' signal
     * and all interested consumers of it, will consume this interface exposed signal.
     */
    _updateDirectionality() {
        merge(toObservable(this.dir, { injector: this._injector }), this._dir.change)
            .pipe(takeUntil(this._destroyed), tap((dir) => this.direction.set(dir)))
            .subscribe();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.1", type: BrnSliderDirective, isStandalone: true, selector: "[brnSlider]", inputs: { label: { classPropertyName: "label", publicName: "label", isSignal: true, isRequired: false, transformFunction: null }, ariaLabel: { classPropertyName: "ariaLabel", publicName: "ariaLabel", isSignal: true, isRequired: false, transformFunction: null }, dir: { classPropertyName: "dir", publicName: "dir", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "brnSliderDisabled", isSignal: true, isRequired: false, transformFunction: null }, min: { classPropertyName: "min", publicName: "min", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "max", isSignal: true, isRequired: false, transformFunction: null }, step: { classPropertyName: "step", publicName: "step", isSignal: true, isRequired: false, transformFunction: null }, showTickMarks: { classPropertyName: "showTickMarks", publicName: "showTickMarks", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { disabled: "brnSliderDisabledChange", min: "minChange", max: "maxChange" }, providers: [
            {
                provide: BRN_SLIDER,
                useExisting: BrnSliderDirective,
            },
        ], queries: [{ propertyName: "brnSliderTrack", first: true, predicate: BRN_SLIDER_TRACK, descendants: true, isSignal: true }], exportAs: ["brnSlider"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSlider]',
                    standalone: true,
                    providers: [
                        {
                            provide: BRN_SLIDER,
                            useExisting: BrnSliderDirective,
                        },
                    ],
                    exportAs: 'brnSlider',
                }]
        }] });
class BrnSliderTrackDirective {
    hostElementWidth = signal(0);
    _destroyed = new Subject();
    _slider = inject(BRN_SLIDER);
    _platformId = inject(PLATFORM_ID);
    _elementRef = inject((ElementRef));
    _sharedResizeObserver = inject(SharedResizeObserver);
    brnSliderInput = contentChild(forwardRef(() => BRN_SLIDER_INPUT));
    activeTrackPercentage = computed(() => {
        const inputValue = this.brnSliderInput()?.value();
        if (this._slider.min() >= this._slider.max() || !inputValue || inputValue < this._slider.min()) {
            return 0;
        }
        if (inputValue > this._slider.max()) {
            return 1;
        }
        return (inputValue - this._slider.min()) / (this._slider.max() - this._slider.min());
    });
    tickMarkTrackWidth = computed(() => {
        if (!this._slider.showTickMarks()) {
            return 0;
        }
        const sliderStep = this._slider.step();
        const sliderMax = this._slider.max();
        const sliderMin = this._slider.min();
        const step = sliderStep && sliderStep > 0 ? sliderStep : 1;
        const maxValue = Math.floor((sliderMax - sliderMin) / step) * step + sliderMin;
        const percentage = (maxValue - sliderMin) / (sliderMax - sliderMin);
        return this.hostElementWidth() * percentage;
    });
    tickMarks = computed(() => {
        const inputValue = this.brnSliderInput()?.value();
        if (!this._slider.showTickMarks() || inputValue === null || inputValue === undefined) {
            return [];
        }
        let numActive = Math.max(Math.floor((inputValue - this._slider.min()) / this._slider.step()), 0);
        let numInactive = Math.max(Math.floor((this._slider.max() - inputValue) / this._slider.step()), 0);
        this._slider.direction() === 'rtl' ? numInactive++ : numActive++;
        return Array(numActive).fill(true).concat(Array(numInactive).fill(false));
    });
    ngAfterViewInit() {
        if (isPlatformBrowser(this._platformId)) {
            this._storeDimensions();
            this._onResize();
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    _onResize() {
        this._sharedResizeObserver
            .observe(this._elementRef.nativeElement)
            .pipe(debounceTime(32), takeUntil(this._destroyed), tap(() => this._storeDimensions()))
            .subscribe();
    }
    _storeDimensions() {
        const computedStyle = getComputedStyle(this._elementRef.nativeElement);
        this.hostElementWidth.set(this._elementRef.nativeElement.offsetWidth -
            Number.parseFloat(computedStyle.paddingLeft) -
            Number.parseFloat(computedStyle.paddingRight));
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderTrackDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.1", type: BrnSliderTrackDirective, isStandalone: true, selector: "[brnSliderTrack]", providers: [
            {
                provide: BRN_SLIDER_TRACK,
                useExisting: BrnSliderTrackDirective,
            },
        ], queries: [{ propertyName: "brnSliderInput", first: true, predicate: i0.forwardRef(() => BRN_SLIDER_INPUT), descendants: true, isSignal: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderTrackDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSliderTrack]',
                    standalone: true,
                    providers: [
                        {
                            provide: BRN_SLIDER_TRACK,
                            useExisting: BrnSliderTrackDirective,
                        },
                    ],
                }]
        }] });

class BrnSliderThumbDirective {
    _platformId = inject(PLATFORM_ID);
    _elementRef = inject((ElementRef));
    _slider = inject(BRN_SLIDER);
    translateX = computed(() => this._calcTranslateX());
    constructor() {
        effect(() => {
            if (isPlatformBrowser(this._platformId)) {
                this._updateTranslateX(this.translateX());
            }
        });
    }
    _calcTranslateX() {
        const activeTrackPercentage = this._slider.brnSliderTrack()?.activeTrackPercentage();
        const trackHostElementWidth = this._slider.brnSliderTrack()?.hostElementWidth();
        if (!activeTrackPercentage || !trackHostElementWidth) {
            return 0;
        }
        if (this._slider.direction() === 'rtl') {
            return -(activeTrackPercentage * trackHostElementWidth);
        }
        return activeTrackPercentage * trackHostElementWidth;
    }
    _updateTranslateX(value) {
        this._elementRef.nativeElement.style.transform = `translate(${value}px, -50%)`;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderThumbDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.1", type: BrnSliderThumbDirective, isStandalone: true, selector: "[brnSliderThumb]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderThumbDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSliderThumb]',
                    standalone: true,
                }]
        }], ctorParameters: () => [] });

class BrnSliderTickMarkDirective {
    _platformId = inject(PLATFORM_ID);
    data = input();
    _sliderTrack = inject(BRN_SLIDER_TRACK);
    _elementRef = inject((ElementRef));
    _slider = inject(BRN_SLIDER);
    constructor() {
        effect(() => {
            if (isPlatformBrowser(this._platformId)) {
                this._updateTranslateX();
            }
        });
    }
    _updateTranslateX() {
        const data = this.data();
        if (!data) {
            return;
        }
        const translateX = data.tickMarkIndex * (this._sliderTrack.tickMarkTrackWidth() / (data.totalTickMarks - 1));
        this._elementRef.nativeElement.style.transform =
            this._slider.direction() === 'rtl' ? `translateX(${-translateX}px)` : `translateX(${translateX}px)`;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderTickMarkDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.1", type: BrnSliderTickMarkDirective, isStandalone: true, selector: "[brnSliderTickMark]", inputs: { data: { classPropertyName: "data", publicName: "data", isSignal: true, isRequired: false, transformFunction: null } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderTickMarkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSliderTickMark]',
                    standalone: true,
                }]
        }], ctorParameters: () => [] });

class BrnSliderTrackActiveFillDirective {
    _platformId = inject(PLATFORM_ID);
    _elementRef = inject((ElementRef));
    _sliderTrack = inject(BRN_SLIDER_TRACK);
    constructor() {
        effect(() => {
            if (isPlatformBrowser(this._platformId)) {
                this._updateActiveTrackPercentage(this._sliderTrack.activeTrackPercentage());
            }
        });
    }
    _updateActiveTrackPercentage(percentage) {
        this._elementRef.nativeElement.style.transform = `scaleX(${percentage})`;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderTrackActiveFillDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.1", type: BrnSliderTrackActiveFillDirective, isStandalone: true, selector: "[brnSliderTrackActiveFill]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.1", ngImport: i0, type: BrnSliderTrackActiveFillDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSliderTrackActiveFill]',
                    standalone: true,
                }]
        }], ctorParameters: () => [] });

const BrnSliderImports = [
    BrnSliderDirective,
    BrnSliderTrackDirective,
    BrnSliderInputDirective,
    BrnSliderThumbDirective,
];

/**
 * Generated bundle index. Do not edit.
 */

export { BRN_SLIDER, BRN_SLIDER_INPUT, BRN_SLIDER_TRACK, BrnSliderDirective, BrnSliderImports, BrnSliderInputDirective, BrnSliderThumbDirective, BrnSliderTickMarkDirective, BrnSliderTrackActiveFillDirective, BrnSliderTrackDirective };
//# sourceMappingURL=spartan-ng-brain-slider.mjs.map
